<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>EQ Reference Comparison</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fa;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 2rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #e9ecef;
    }

    .header h2 {
      margin: 0;
      border: none;
      padding: 0;
    }

    .header-links {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-left: auto;
    }

    .header-link {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      color: #0366d6;
      text-decoration: none;
      font-weight: 500;
      padding: 8px 12px;
      border-radius: 6px;
      transition: background-color 0.2s;
    }

    .header-link:hover {
      background-color: rgba(3, 102, 214, 0.1);
      text-decoration: none;
    }

    .header-link img {
      width: 20px;
      height: 20px;
      object-fit: contain;
    }

    .meternum-logo {
      width: 20px;
      height: 20px;
      object-fit: contain;
    }

    h2 {
      color: #2c3e50;
      margin-bottom: 1.5rem;
      font-size: 2rem;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 0.5rem;
    }

    h3 {
      color: #2c3e50;
      margin: 1.5rem 0 1rem;
      font-size: 1.5rem;
    }

    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .file-input-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .file-input-container input[type="file"] {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    .file-input-container span {
      color: #666;
      font-size: 0.9rem;
    }

    .waveform-container {
      margin: 20px 0;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .waveform-wrapper {
      position: relative;
      flex-grow: 1;
    }

    .waveform {
      border: 1px solid #e9ecef;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      height: 100px;
      background: #f8f9fa;
    }

    .selection {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(0, 123, 255, 0.1);
      border: 1px solid #007bff;
      pointer-events: none;
      border-radius: 4px;
    }

    .chart-controls {
      margin: 15px 0;
      display: flex;
      gap: 10px;
    }

    .chart-controls button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .chart-controls button:hover {
      background: #0056b3;
    }

    .analysis-controls {
      margin: 15px 0;
      display: flex;
      align-items: center;
      gap: 15px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .analysis-controls label {
      min-width: 150px;
      color: #495057;
      font-weight: 500;
    }

    .analysis-controls input[type="range"] {
      flex: 1;
    }

    .play-button {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #007bff;
      background: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      user-select: none;
      flex-shrink: 0;
      color: #007bff;
      transition: all 0.2s;
    }

    .play-button:hover {
      background: #007bff;
      color: white;
    }

    .play-button:active {
      transform: scale(0.95);
    }

    #eqChart {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      margin: 20px 0;
    }

    .mixing-advice-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .mixing-advice-section input[type="password"],
    .mixing-advice-section input[type="text"] {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .mixing-advice-section button {
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .mixing-advice-section button:hover {
      background: #218838;
    }

    .mixing-advice-section button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    .mixing-advice-container {
      position: relative;
      width: 100%;
      overflow-x: auto;
      background: #f8f9fa;
      border-radius: 4px;
      padding: 15px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre;
      tab-size: 4;
      -moz-tab-size: 4;
      max-width: 100%;
      box-sizing: border-box;
    }

    #mixingAdvice {
      width: 100%;
      height: 400px;
      padding: 0;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
      border: none;
      background: transparent;
      resize: vertical;
      white-space: pre;
      tab-size: 4;
      -moz-tab-size: 4;
      overflow-x: auto;
      max-width: 100%;
      box-sizing: border-box;
    }

    /* Style for markdown tables */
    .mixing-advice-container table {
      border-collapse: collapse;
      margin: 10px 0;
      width: auto;
      min-width: 100%;
      font-family: inherit;
      table-layout: fixed;
    }

    .mixing-advice-container table td,
    .mixing-advice-container table th {
      padding: 4px 8px;
      border: 1px solid #ddd;
      text-align: left;
      word-wrap: break-word;
      max-width: 200px;
    }

    .mixing-advice-container table th {
      background: #e9ecef;
      font-weight: bold;
    }

    .mixing-advice-container table tr:nth-child(even) {
      background: #f1f3f5;
    }

    /* Style for markdown table separators */
    .mixing-advice-container table tr:first-child td {
      border-bottom: 2px solid #666;
    }

    .mixing-advice-container table tr:nth-child(2) td {
      border-bottom: 1px solid #999;
    }

    .github-link {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      color: #0366d6;
      text-decoration: none;
      font-weight: 500;
      margin-bottom: 20px;
    }

    .github-link:hover {
      text-decoration: underline;
    }

    .github-link img {
      width: 16px;
      height: 16px;
    }
  </style>
</head>

<body>
  <div class="header">
    <h2>EQ Reference Comparison </h2>
    <div class="header-links">
      <a href="https://meternum.com" target="_blank" class="header-link">
        <img class="meternum-logo"
          src="data:image/png;base64,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"
          alt="Memento Eternum Logo">
        By Memento Eternum
      </a>
      <a href="https://github.com/royk/compareeq" target="_blank" class="header-link">
        <img src="https://github.com/favicon.ico" alt="GitHub">
        View on GitHub
      </a>

    </div>
  </div>

  <div class="section">
    <div class="file-input-container">
      <input type="file" id="yourTrack" accept="audio/*">
      <span id="yourTrackName"></span>
    </div>
    <div class="waveform-container">
      <button class="play-button" id="yourPlayButton">▶</button>
      <div class="waveform-wrapper">
        <canvas id="yourWaveform" class="waveform"></canvas>
        <div id="yourSelection" class="selection"></div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="file-input-container">
      <input type="file" id="refTrack" accept="audio/*">
      <span id="refTrackName"></span>
    </div>
    <div class="waveform-container">
      <button class="play-button" id="refPlayButton">▶</button>
      <div class="waveform-wrapper">
        <canvas id="refWaveform" class="waveform"></canvas>
        <div id="refSelection" class="selection"></div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="analysis-controls">
      <label for="analysisLength">Analysis Length (seconds):</label>
      <input type="range" id="analysisLength" min="0.1" max="5" step="0.1" value="5">
      <span id="analysisLengthValue">5.0</span>
    </div>
    <div class="analysis-controls">
      <label for="smoothingFactor">Smoothing:</label>
      <input type="range" id="smoothingFactor" min="0" max="1" step="0.01" value="1">
      <span id="smoothingValue">1/3 Octave</span>
    </div>
    <div class="chart-controls">
      <button onclick="resetZoom()">Reset Zoom</button>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
    </div>
    <canvas id="eqChart" width="1000" height="400"></canvas>
  </div>

  <div class="mixing-advice-section">
    <div class="analysis-controls">
      <label for="openaiKey">OpenAI API Key:</label>
      <input type="password" id="openaiKey">
      <button id="getAdviceButton" disabled>Get Mixing Advice</button>
    </div>
    <div style="margin: 15px 0;">
      <label for="customPrompt">Additional Context (optional):</label>
      <input type="text" id="customPrompt"
        placeholder="Add genre, key, or any other relevant information to help with the mixing advice (e.g., 'This is a rock track in E minor, aiming for a warm vintage sound')">
    </div>
    <h3>Mixing Advice</h3>
    <div class="mixing-advice-container">
      <textarea id="mixingAdvice" readonly></textarea>
    </div>
  </div>

  <script>
    // Global function for getting mixing advice
    async function getMixingAdvice() {
      const apiKey = document.getElementById('openaiKey').value;
      if (!apiKey) {
        document.getElementById('mixingAdvice').value = 'Please enter your OpenAI API key';
        return;
      }

      if (!window.currentChart) {
        document.getElementById('mixingAdvice').value = 'Please analyze audio files first';
        return;
      }

      const button = document.getElementById('getAdviceButton');
      button.disabled = true;
      button.textContent = 'Getting Advice...';
      document.getElementById('mixingAdvice').value = 'Getting mixing advice...';

      try {
        // Get the chart canvas
        const canvas = document.getElementById('eqChart');

        // Convert canvas to base64 image
        const imageData = canvas.toDataURL('image/png').split(',')[1]; // Get just the base64 data without the prefix

        // Create the prompt
        const analysisLength = document.getElementById('analysisLength').value;
        const customPrompt = document.getElementById('customPrompt').value;
        const prompt = `I have analyzed two audio tracks and found the frequency differences shown in this chart. The blue line is the first track, and the green line is the reference track. This analysis is an average over ${analysisLength} seconds of audio, with LUFs matched.${customPrompt ? ` Additional context: ${customPrompt}` : ''} Please provide specific mixing advice on what changes, if any, you would make to the first track based on the reference track. Please provide specific EQ recommendations and mixing tips to help get the first track to sound professional, based on that the reference track is a professional mix.`;

        // Send to OpenAI
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4.1-mini',
            messages: [
              {
                role: 'system',
                content: 'You are an expert audio engineer with deep knowledge of mixing and EQ. Provide specific, actionable advice for mixing the first track to sound professional, based on that the reference track is a professional mix. Provide a table in the end with the an EQ curve example based on your recommendations (frequency, gain, q, note)'
              },
              {
                role: 'user',
                content: [
                  { type: "text", text: prompt },
                  {
                    type: "image_url",
                    image_url: {
                      url: `data:image/png;base64,${imageData}`
                    }
                  }
                ]
              }
            ],
            max_tokens: 5000
          })
        });

        const data = await response.json();
        if (data.choices && data.choices[0]) {
          document.getElementById('mixingAdvice').value = data.choices[0].message.content;
        } else {
          throw new Error('No response from OpenAI');
        }
      } catch (error) {
        console.error('Error getting mixing advice:', error);
        document.getElementById('mixingAdvice').value = 'Error getting mixing advice. Please check your API key and try again.';
      } finally {
        button.disabled = false;
        button.textContent = 'Get Mixing Advice';
      }
    }

    // Add event listener for the advice button
    document.getElementById('getAdviceButton').addEventListener('click', getMixingAdvice);

    // Add event listener for API key input
    document.getElementById('openaiKey').addEventListener('input', (e) => {
      document.getElementById('getAdviceButton').disabled = !e.target.value;
    });

    // Read API key from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const apiKey = urlParams.get('key');
    if (apiKey) {
      document.getElementById('openaiKey').value = apiKey;
      document.getElementById('getAdviceButton').disabled = false;
    }
  </script>

  <script type="module">
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const windowSize = 2048;
    let yourBuffer = null;
    let refBuffer = null;
    let yourStartSample = 0;
    let refStartSample = 0;
    window.currentChart = null;  // Make currentChart globally accessible
    let analysisLength = 5.0; // Default analysis length in seconds
    let smoothingFactor = 1.0; // Default smoothing factor (1 = 1/3 octave)
    let yourSource = null;
    let refSource = null;
    let yourPlayButton = null;
    let refPlayButton = null;

    // Update smoothing factor display
    document.getElementById('smoothingFactor').addEventListener('input', (e) => {
      smoothingFactor = parseFloat(e.target.value);
      const displayText = smoothingFactor === 0 ? 'No Smoothing' :
        smoothingFactor === 1 ? '1/3 Octave' :
          `${Math.round(smoothingFactor * 100)}%`;
      document.getElementById('smoothingValue').textContent = displayText;
      if (yourBuffer && refBuffer) analyze();
    });

    // Setup play buttons
    function setupPlayButton(button, buffer, startSample) {
      if (button.id === 'yourPlayButton') {
        yourPlayButton = { button, buffer, startSample };
      } else {
        refPlayButton = { button, buffer, startSample };
      }

      button.addEventListener('mousedown', () => {
        if (!buffer) return;

        // Create new source
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);

        // Get current start sample
        const currentStart = button.id === 'yourPlayButton' ? yourStartSample : refStartSample;

        // Start from the current playhead position
        source.start(0, currentStart / buffer.sampleRate);

        // Store source for stopping
        if (button.id === 'yourPlayButton') {
          yourSource = source;
        } else {
          refSource = source;
        }
      });

      button.addEventListener('mouseup', () => {
        const source = button.id === 'yourPlayButton' ? yourSource : refSource;
        if (source) {
          source.stop();
          if (button.id === 'yourPlayButton') {
            yourSource = null;
          } else {
            refSource = null;
          }
        }
      });

      // Also stop on mouseleave in case user moves mouse away while holding
      button.addEventListener('mouseleave', () => {
        const source = button.id === 'yourPlayButton' ? yourSource : refSource;
        if (source) {
          source.stop();
          if (button.id === 'yourPlayButton') {
            yourSource = null;
          } else {
            refSource = null;
          }
        }
      });
    }

    // Update play button start position
    function updatePlayButtonStart(button, startSample) {
      if (button.id === 'yourPlayButton') {
        yourStartSample = startSample;
      } else {
        refStartSample = startSample;
      }
    }

    // Convert frequency to note name
    function freqToNote(freq) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const a4 = 440; // A4 = 440Hz
      const a4Index = 69; // MIDI note number for A4

      if (freq < 20) return ''; // Too low to be a note

      // Calculate MIDI note number
      const midiNote = Math.round(12 * Math.log2(freq / a4) + a4Index);

      // Get note name and octave
      const noteName = noteNames[midiNote % 12];
      const octave = Math.floor(midiNote / 12) - 1;

      return `${noteName}${octave}`;
    }

    // Update analysis length display
    document.getElementById('analysisLength').addEventListener('input', (e) => {
      analysisLength = parseFloat(e.target.value);
      document.getElementById('analysisLengthValue').textContent = analysisLength.toFixed(1);
      if (yourBuffer && refBuffer) analyze();
    });

    // Make zoom functions available globally
    window.resetZoom = function () {
      if (window.currentChart) {
        window.currentChart.resetZoom();
      }
    };

    window.zoomIn = function () {
      if (window.currentChart) {
        window.currentChart.zoom(1.5);
      }
    };

    window.zoomOut = function () {
      if (window.currentChart) {
        window.currentChart.zoom(0.75);
      }
    };

    async function decodeFile(file) {
      const arrayBuffer = await file.arrayBuffer();
      return await audioCtx.decodeAudioData(arrayBuffer);
    }

    function drawWaveform(canvas, buffer, startSample = 0) {
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const data = buffer.getChannelData(0);

      // Clear canvas
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);

      // Draw waveform
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.beginPath();

      const step = Math.ceil(data.length / width);
      const amp = height / 2;

      for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;
        for (let j = 0; j < step; j++) {
          const datum = data[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.moveTo(i, (1 + min) * amp);
        ctx.lineTo(i, (1 + max) * amp);
      }

      ctx.stroke();

      // Draw selection
      const selection = canvas.parentElement.querySelector('.selection');
      selection.style.left = (startSample / data.length * width) + 'px';
      selection.style.width = (windowSize / data.length * width) + 'px';
    }

    function getRMS(data, start, size) {
      let sum = 0;
      for (let i = start; i < start + size; i++) {
        const sample = data[i] || 0;
        sum += sample * sample;
      }
      return Math.sqrt(sum / size);
    }

    // Calculate LUFS for a given audio segment
    function calculateLUFS(data, start, size, sampleRate) {
      // K-weighting filter coefficients (simplified)
      const k1 = 1.0;
      const k2 = 1.4;
      const k3 = 1.0;

      // Pre-filtering stage
      const filtered = new Float32Array(size);
      for (let i = 0; i < size; i++) {
        const sample = data[start + i] || 0;
        // Simplified K-weighting filter
        filtered[i] = sample * k1 * k2 * k3;
      }

      // Calculate RMS with 400ms integration time
      const integrationTime = 0.4; // seconds
      const samplesPerBlock = Math.floor(sampleRate * integrationTime);
      let sum = 0;
      let count = 0;

      for (let i = 0; i < size; i += samplesPerBlock) {
        const blockSize = Math.min(samplesPerBlock, size - i);
        let blockSum = 0;

        for (let j = 0; j < blockSize; j++) {
          const sample = filtered[i + j];
          blockSum += sample * sample;
        }

        sum += Math.sqrt(blockSum / blockSize);
        count++;
      }

      // Calculate average and convert to LUFS
      const average = sum / count;
      return -0.691 + 10 * Math.log10(average * average);
    }

    // Match LUFS levels between two segments
    function matchLUFS(data1, start1, size1, data2, start2, size2, sampleRate) {
      const lufs1 = calculateLUFS(data1, start1, size1, sampleRate);
      const lufs2 = calculateLUFS(data2, start2, size2, sampleRate);
      const gainDiff = lufs2 - lufs1;
      return Math.pow(10, gainDiff / 20); // Convert dB to linear gain
    }

    function findLoudestSegment(buffer, windowSize) {
      const data = buffer.getChannelData(0);
      let maxRMS = 0;
      let maxIndex = 0;
      for (let i = 0; i < data.length - windowSize; i += windowSize / 4) {
        const rms = getRMS(data, i, windowSize);
        if (rms > maxRMS) {
          maxRMS = rms;
          maxIndex = i;
        }
      }
      return { startSample: maxIndex, length: windowSize };
    }

    function getFrequencies(sampleRate, fftSize) {
      const freqs = [];
      for (let i = 0; i < fftSize / 2; i++) {
        freqs.push(i * sampleRate / fftSize);
      }
      return freqs;
    }

    // Calculate 1/3 octave band frequencies
    function getThirdOctaveBands(minFreq, maxFreq) {
      const bands = [];
      let f = minFreq;
      while (f <= maxFreq) {
        bands.push(f);
        f *= Math.pow(2, 1 / 3); // Multiply by 2^(1/3) to get next 1/3 octave
      }
      return bands;
    }

    // Get the frequency band index for a given frequency
    function getBandIndex(freq, bands) {
      for (let i = 0; i < bands.length - 1; i++) {
        if (freq >= bands[i] && freq < bands[i + 1]) {
          return i;
        }
      }
      return bands.length - 1;
    }

    function analyzeFFT(buffer, startSample, fftSize) {
      const data = buffer.getChannelData(0);
      const numWindows = Math.floor(fftSize / (windowSize / 2));
      const windowStep = windowSize / 2;

      // Initialize arrays for averaging
      const realSum = new Float32Array(windowSize);
      const imagSum = new Float32Array(windowSize);

      // Process multiple windows across the analysis section
      for (let w = 0; w < numWindows; w++) {
        const windowStart = startSample + (w * windowStep);

        if (windowStart < 0 || windowStart + windowSize > data.length) continue;

        const windowData = data.slice(windowStart, windowStart + windowSize);

        // Apply Hanning window
        const windowedData = new Float32Array(windowSize);
        for (let i = 0; i < windowSize; i++) {
          windowedData[i] = windowData[i] * (0.5 * (1 - Math.cos((2 * Math.PI * i) / (windowSize - 1))));
        }

        // Perform FFT
        const real = new Float32Array(windowSize);
        const imag = new Float32Array(windowSize);

        for (let i = 0; i < windowSize; i++) {
          real[i] = windowedData[i];
          imag[i] = 0;
        }

        // Cooley-Tukey FFT
        function fft(real, imag) {
          const n = real.length;
          if (n <= 1) return;

          const half = n / 2;
          const realEven = new Float32Array(half);
          const imagEven = new Float32Array(half);
          const realOdd = new Float32Array(half);
          const imagOdd = new Float32Array(half);

          for (let i = 0; i < half; i++) {
            realEven[i] = real[i * 2];
            imagEven[i] = imag[i * 2];
            realOdd[i] = real[i * 2 + 1];
            imagOdd[i] = imag[i * 2 + 1];
          }

          fft(realEven, imagEven);
          fft(realOdd, imagOdd);

          for (let k = 0; k < half; k++) {
            const angle = -2 * Math.PI * k / n;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const realTemp = realOdd[k] * cos - imagOdd[k] * sin;
            const imagTemp = realOdd[k] * sin + imagOdd[k] * cos;
            real[k] = realEven[k] + realTemp;
            imag[k] = imagEven[k] + imagTemp;
            real[k + half] = realEven[k] - realTemp;
            imag[k + half] = imagEven[k] - imagTemp;
          }
        }

        fft(real, imag);

        for (let i = 0; i < windowSize; i++) {
          realSum[i] += real[i];
          imagSum[i] += imag[i];
        }
      }

      // Calculate raw spectrum
      const spectrum = new Float32Array(windowSize / 2);
      const sampleRate = buffer.sampleRate;

      for (let i = 0; i < windowSize / 2; i++) {
        const magnitude = Math.sqrt(realSum[i] * realSum[i] + imagSum[i] * imagSum[i]) / numWindows;
        spectrum[i] = 20 * Math.log10(magnitude + 1e-10);
      }

      // Apply smoothing based on smoothing factor
      const smoothedSpectrum = new Float32Array(windowSize / 2);
      const thirdOctaveBands = getThirdOctaveBands(20, sampleRate / 2);
      const bandValues = new Float32Array(thirdOctaveBands.length);
      const bandCounts = new Float32Array(thirdOctaveBands.length);

      // Calculate 1/3 octave band values
      for (let i = 0; i < windowSize / 2; i++) {
        const freq = i * sampleRate / windowSize;
        const bandIndex = getBandIndex(freq, thirdOctaveBands);
        bandValues[bandIndex] += spectrum[i];
        bandCounts[bandIndex]++;
      }

      // Average band values
      for (let i = 0; i < thirdOctaveBands.length; i++) {
        if (bandCounts[i] > 0) {
          bandValues[i] /= bandCounts[i];
        }
      }

      // Interpolate between raw and 1/3 octave smoothed values
      for (let i = 0; i < windowSize / 2; i++) {
        const freq = i * sampleRate / windowSize;
        const bandIndex = getBandIndex(freq, thirdOctaveBands);
        const smoothedValue = bandValues[bandIndex];

        // Apply minimum smoothing to frequencies above 1.5kHz
        let effectiveSmoothingFactor = smoothingFactor;
        let baseSmoothing = smoothingFactor>0.5 ? 0.6 : 0.3
        if (freq >= 1500) {
          // Increase minimum smoothing for high frequencies
          effectiveSmoothingFactor = Math.max(smoothingFactor, baseSmoothing);
        }
        if (freq >= 5000) {
          // Even more smoothing for very high frequencies
          effectiveSmoothingFactor = Math.max(smoothingFactor, baseSmoothing+0.1);
        }
        if (freq >= 10000) {
          // Even more smoothing for very high frequencies
          effectiveSmoothingFactor = Math.max(smoothingFactor, baseSmoothing+0.2);
        }
        if (freq >= 15000) {
          // Even more smoothing for very high frequencies
          effectiveSmoothingFactor = Math.max(smoothingFactor, baseSmoothing+0.3);
        }

        smoothedSpectrum[i] = spectrum[i] * (1 - effectiveSmoothingFactor) + smoothedValue * effectiveSmoothingFactor;
      }

      return Array.from(smoothedSpectrum);
    }

    async function process(file, label, color, buffer, startSample, gain = 1.0, analysisSize = windowSize) {
      const spectrum = analyzeFFT(buffer, startSample, analysisSize);
      const freqs = getFrequencies(buffer.sampleRate, windowSize); // Use windowSize for frequency calculation
      // Apply gain to spectrum
      const adjustedSpectrum = spectrum.map(value => value + 20 * Math.log10(gain));
      return { label, freqs, spectrum: adjustedSpectrum, color };
    }

    async function analyze() {
      if (!yourBuffer || !refBuffer) return;

      try {
        // Use the selected analysis length
        const analysisWindowSize = Math.floor(Math.min(yourBuffer.sampleRate, refBuffer.sampleRate) * analysisLength);
        const yourAnalysisStart = Math.max(0, yourStartSample - analysisWindowSize / 2);
        const refAnalysisStart = Math.max(0, refStartSample - analysisWindowSize / 2);

        // Calculate LUFS matching gain using the longer section
        const gain = matchLUFS(
          yourBuffer.getChannelData(0), yourAnalysisStart, analysisWindowSize,
          refBuffer.getChannelData(0), refAnalysisStart, analysisWindowSize,
          yourBuffer.sampleRate
        );

        const [yourData, refData] = await Promise.all([
          process(null, 'Your Track', 'blue', yourBuffer, yourAnalysisStart, gain, analysisWindowSize),
          process(null, 'Reference Track', 'green', refBuffer, refAnalysisStart, 1.0, analysisWindowSize)
        ]);

        const ctx = document.getElementById("eqChart").getContext("2d");

        // Destroy previous chart if it exists
        if (window.currentChart) {
          window.currentChart.destroy();
        }

        window.currentChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: yourData.freqs,
            datasets: [
              {
                label: yourData.label,
                data: yourData.spectrum,
                borderColor: yourData.color,
                borderWidth: 2,
                pointRadius: 0
              },
              {
                label: refData.label,
                data: refData.spectrum,
                borderColor: refData.color,
                borderWidth: 2,
                pointRadius: 0
              }
            ]
          },
          options: {
            scales: {
              x: {
                type: 'logarithmic',
                title: {
                  display: true,
                  text: 'Frequency (Hz)',
                  font: {
                    size: 14,
                    weight: 'bold'
                  }
                },
                min: 20,
                max: 20000,
                ticks: {
                  font: {
                    size: 12
                  },
                  callback: function (value) {
                    if (value >= 1000) {
                      return (value / 1000) + 'k';
                    }
                    return value;
                  }
                },
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)'
                }
              },
              y: {
                title: {
                  display: true,
                  text: 'Magnitude (dB)',
                  font: {
                    size: 14,
                    weight: 'bold'
                  }
                },
                min: function (context) {
                  const chart = context.chart;
                  const { min, max } = chart.scales.y;
                  const range = max - min;
                  return min - range * 0.1;
                },
                max: function (context) {
                  const chart = context.chart;
                  const { min, max } = chart.scales.y;
                  const range = max - min;
                  return max + range * 0.1;
                },
                ticks: {
                  font: {
                    size: 12
                  }
                },
                grid: {
                  color: 'rgba(0, 0, 0, 0.1)'
                }
              }
            },
            responsive: false,
            interaction: {
              mode: 'index',
              intersect: false
            },
            plugins: {
              legend: {
                position: 'top',
                labels: {
                  font: {
                    size: 14,
                    weight: 'bold'
                  },
                  padding: 20
                }
              },
              zoom: {
                pan: {
                  enabled: true,
                  mode: 'xy'
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true
                  },
                  mode: 'xy',
                }
              },
              tooltip: {
                enabled: true,
                mode: 'index',
                intersect: false,
                callbacks: {
                  title: function (context) {
                    const freq = parseFloat(context[0].label.replace(/,/g, ''));
                    const note = freqToNote(freq);
                    if (freq >= 1000) {
                      return `Frequency: ${(freq / 1000).toFixed(1)} kHz${note ? ` (${note})` : ''}`;
                    }
                    return `Frequency: ${Math.round(freq)} Hz${note ? ` (${note})` : ''}`;
                  },
                  label: function (context) {
                    const dataset = context.dataset;
                    const value = context.raw;
                    return `${dataset.label}: ${value.toFixed(1)} dB`;
                  },
                  afterBody: function (context) {
                    if (context.length > 1) {
                      const diff = context[1].raw - context[0].raw;
                      return [`Difference: ${diff.toFixed(1)} dB`];
                    }
                    return [];
                  }
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error analyzing audio:', error);
      }
    }

    document.getElementById("yourTrack").addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (file) {
        document.getElementById("yourTrack").style.display = "none";
        document.getElementById("yourTrackName").textContent = file.name;

        yourBuffer = await decodeFile(file);
        const { startSample } = findLoudestSegment(yourBuffer, windowSize);
        yourStartSample = startSample;
        const canvas = document.getElementById("yourWaveform");
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = 100;
        drawWaveform(canvas, yourBuffer, yourStartSample);

        // Setup interaction after buffer is loaded
        canvas.onclick = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const newStartSample = Math.floor((x / rect.width) * yourBuffer.length);
          yourStartSample = newStartSample;
          drawWaveform(canvas, yourBuffer, yourStartSample);
          if (refBuffer) analyze(); // Only analyze if both files are loaded
        };

        // Setup play button
        setupPlayButton(document.getElementById("yourPlayButton"), yourBuffer, yourStartSample);

        // Run analysis if reference file is already loaded
        if (refBuffer) analyze();
      }
    });

    document.getElementById("refTrack").addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (file) {
        document.getElementById("refTrack").style.display = "none";
        document.getElementById("refTrackName").textContent = file.name;

        refBuffer = await decodeFile(file);
        const { startSample } = findLoudestSegment(refBuffer, windowSize);
        refStartSample = startSample;
        const canvas = document.getElementById("refWaveform");
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = 100;
        drawWaveform(canvas, refBuffer, refStartSample);

        // Setup interaction after buffer is loaded
        canvas.onclick = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const newStartSample = Math.floor((x / rect.width) * refBuffer.length);
          refStartSample = newStartSample;
          drawWaveform(canvas, refBuffer, refStartSample);
          if (yourBuffer) analyze(); // Only analyze if both files are loaded
        };

        // Setup play button
        setupPlayButton(document.getElementById("refPlayButton"), refBuffer, refStartSample);

        // Run analysis if your file is already loaded
        if (yourBuffer) analyze();
      }
    });
  </script>
  <script src='https://storage.ko-fi.com/cdn/scripts/overlay-widget.js'></script>
  <script>
    kofiWidgetOverlay.draw('royklein', {
      'type': 'floating-chat',
      'floating-chat.donateButton.text': 'Support me',
      'floating-chat.donateButton.background-color': '#00b9fe',
      'floating-chat.donateButton.text-color': '#fff'
    });
  </script>
  <style>
    .floatingchat-container-wrap {
      left: unset;
      right: 50px;
      width: 50%;
    }

    .floatingchat-container-wrap-mobi {
      left: unset;
      right: 50px;
      width: 50%;
    }

    .floating-chat-kofi-popup-iframe {
      left: unset;
      right: 50px;
    }

    .floating-chat-kofi-popup-iframe-mobi {
      left: unset;
      right: 50px;
    }

    .floating-chat-kofi-popup-iframe-closer-mobi {
      left: unset;
      right: 50px;
    }
  </style>
</body>

</html>